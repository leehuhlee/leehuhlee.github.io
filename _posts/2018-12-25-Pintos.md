---
layout: post
title: "Pintos"
date: 2018-12-25
excerpt: "Pintos project from Stanford University"
tags: [OS, project]
comments: false
---

## What is Pintos?

* Training Operating System for x86 Architecture
* Made in 2004 by Stanford Ben Paff
* Support kernel threads, loading and running user programs, file systems, etc.
* Use x86 simulator such as Bochs or QEMU

## Project 1 : Execute command from command line

* Develops the ability to separate strings of command lines into tokens
  - Pintos can't distinguish between a program and a factor
  - Separate program names and factors from each other and store them in the stack
  - Pass them to the program

* Result
{% highlight vi %}
$ pintos –v -- run ‘echo x’
{% endhighlight %}
<figure>
	<img src="/assets/img/posts/pintos/project1_result.jpg">
	<figcaption>Pintos project #1 result</figcaption>
</figure>

## Project 2 : Prevent data from being written to a running file
If the file data of a running user program changes, it is likely that the program will read the changed data differently from the original expected data.
If this occurs, write access to running user programs at the OS level should be prevented because the currently running program cannot produce the correct computational results.

* To solve this project
  - Need to know exactly where the file is running
  - Modify the data in running program files to prevent changes
  - A function that prevents data change is already implemented in pintos
  - Modify the data in a running file to change only when the program is terminated

* Result<br>
Path : pintos/src/userprog
{% highlight vi %}
$ make grade
{% endhighlight %}
<figure>
	<img src="/assets/img/posts/pintos/project2_result.jpg">
	<figcaption>Pintos project #2 result</figcaption>
</figure>

## Project 3-1 : Priority Scheduling
Currently, the scheduler of the pintos is implemented as a round robin. Modify this scheduler to priority scheduling

* To solve this project
  - Time Quantum: 40 msec (src/thread.c)
  - If the new thread added to the Ready list is higher than the current one, push out the existing thread and allow it to occupy the CPU
  - When multiple threads wait to get lock, semaphore, the highest priority thread takes over the CPU

* Result
{% highlight vi %}
$ make check
{% endhighlight %}
<figure class="half">
	<img src="/assets/img/posts/pintos/project3_result1.jpg">
    <img src="/assets/img/posts/pintos/project3_result2.jpg">
	<figcaption>Pintos project #3 result1</figcaption>
</figure>

## Project 3-2 : Priority Inversion

* To solve this project
  - Implement Priority Donation
  - Implement Multiple Donation
  - Implement Nested Donation

* Multiple Donation<br>
If more than one thread has more than one lock, a donation may occur by each lock.
  - Remember the priority of the previous state
<figure figure class="half">
	<img src="/assets/img/posts/pintos/project3_example_multiple_donation.jpg">
    <img src="/assets/img/posts/pintos/project3_example_multiple_donation2.jpg">
	<figcaption>Pintos project #3 Multiple Donation example</figcaption>
</figure>

* Nested Donation
<figure figure class="half">
	<img src="/assets/img/posts/pintos/project3_example_nested_donation.jpg">
    <img src="/assets/img/posts/pintos/project3_example_nested_donation2.jpg">
	<figcaption>Pintos project #3 Nested Donation example</figcaption>
</figure>

* Result
{% highlight vi %}
$ make check
{% endhighlight %}
<figure >
	<img src="/assets/img/posts/pintos/project3_result3.jpg">
	<figcaption>Pintos project #3 result2</figcaption>
</figure>

## Project 3-3 : Implement Multi-Level Feedback Queue Scheduler

* Priority
  - The larger the number, the higher the priority
  - Initialize when creating threads (default : 31)
  - All thread : Recalculate priority every second<br>
  $$
\begin{align*}
 priority = PRI_{MAX} – (recent_{cpu} / 4) – (nice * 2)
\end{align*}
$$
  - Current thread : Preference recalculation for every 4 clock tick (using formula below)
  - 1 tick is 10 msec (src/thread.c)

* Nice value (-20~20)
  - Nice (0): No impact on priorities
  - Nice (positive) : Reduced priority
  - Nice (negative): Increase priority
  - Initial value : 0

* recent_cpu<br>
  $$
\begin{align*}
 recent_{cpu} = (2 * load_{avg}) / (2 * load_{avg} + 1) * recent_{cpu} + Nice
\end{align*}
$$
  - Express how much CPU time has been used recently
  - Initial value of the initiator thread is '0', and other threads are the parent's recent_cpu value.
  - Recent_cpu increases by 1 per timer interrupt, recalculating every 1 second
  - Implement intread_get_recent_cpu(void) function<br>
    Return thread(s) of 100 times of the current recent_cpu

* load_averge<br>
  $$
\begin{align*}
 load_{avg} = (59/60) * load_{avg} + (1/60) * ready_{threads}
\end{align*}
$$
  - Average number of processes that can be performed in the last 1 minute, using extraordinarily weighted moving average
  - Ready_threads : Number of threads running and threads in the ready_list (excluding the lead threads)
  - Implementing an intread_get_load_avg(void) function
  - Return 100 times the current system load average (round to the need index)
  {% highlight vim %}
    timer_ticks() % TIMER_FREQ == 0
  {% endhighlight %}

  * Result
{% highlight vi %}
$ make check
{% endhighlight %}
<figure >
	<img src="/assets/img/posts/pintos/project3_result4.jpg">
	<figcaption>Pintos project #3 result3</figcaption>
</figure>

## Project 4-1 : Implement of demand paging

* Page fault processing
Pintos is a page_fault() function for processing when a page fault occurs
  Path : pintos/src/userprog/exception.c
  {% highlight vi %}
    static void page_fault (structure intr_frame *f)
  {% endhighlight %}
  - The page_fault processing of the current pintos is generating a "segmentation fault" unconditionally if an error occurs after permisstion or verification of the address, and terminated by kill(-1)
  - Delete processing-related to Kill(-1)
  - Validate of fault_addr
  - Call PageFault Handler Function 
  {% highlight vi %}
    Handle_mm_fault (struct vm_entry *vme)
  {% endhighlight %}
---
layout: post
title: "[C#] Network Programming"
date: 2021-04-04
excerpt: "Socket Programming"
tags: [C#, Server]
comments: false
---

<center>Reference by <a href="https://www.inflearn.com/course/%EC%9C%A0%EB%8B%88%ED%8B%B0-mmorpg-%EA%B0%9C%EB%B0%9C-part4/dashboard">[C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버</a></center>

# Socket Programming
  - Client and Server communicate by Socket

### Test
  - start ServerCore and DummyClient at the same time

* ServerCore\Program.cs
{% highlight C# %}
class Program
{
    static void Main(string[] args)
    {
        // DNS(Domain Name System)
        // ex) www.google.com
        string host = Dns.GetHostName();

        IPHostEntry ipHost = Dns.GetHostEntry(host);
        IPAddress ipAddr = ipHost.AddressList[0];
        IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);

        // Socket is for connection between server and client
        Socket listenSocket = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);

        try
        {
            listenSocket.Bind(endPoint);

            listenSocket.Listen(10);

            while (true)
            {
                Console.WriteLine("Listening...");

                // if there is client, then rest codes excute
                // if there is no client, then wait for client
                Socket clientSocket = listenSocket.Accept();

                // receive client's message in recvBuff
                // store bytes of client's message
                // Server has to wait for client's sending
                byte[] recvBuff = new byte[1024];
                int recvBytes = clientSocket.Receive(recvBuff);
                
                // change client's message to letter, even you can formating by index
                string recvData = Encoding.UTF8.GetString(recvBuff, 0, recvBytes);
                Console.WriteLine($"[From Client] {recvData}");

                // send server's message to client
                // Server has to wait for client's receiving
                byte[] sendBuff = Encoding.UTF8.GetBytes("Welcome to MMORPG Server!");
                clientSocket.Send(sendBuff);

                // close receive and send function
                clientSocket.Shutdown(SocketShutdown.Both);
                clientSocket.Close();
            }
        }
        catch(Exception e)
        {
            Console.WriteLine(e.ToString());
        }
    }
}
{% endhighlight %}

* DummyClient\Program.cs
{% highlight C# %}
class Program
{
    static void Main(string[] args)
    {
        string host = Dns.GetHostName();
        IPHostEntry ipHost = Dns.GetHostEntry(host);
        IPAddress ipAddr = ipHost.AddressList[0];
        IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);

        Socket socket = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);

        try
        {
            socket.Connect(endPoint);
            Console.WriteLine($"Connected To {socket.RemoteEndPoint.ToString()}");

            byte[] sendBuff = Encoding.UTF8.GetBytes("Hello World!");
            int sendBytes = socket.Send(sendBuff);

            byte[] recvBuff = new byte[1024];
            int recvBytes = socket.Receive(recvBuff);
            string recvData = Encoding.UTF8.GetString(recvBuff, 0, recvBytes);
            Console.WriteLine($"[From Server] {recvData}");

            socket.Shutdown(SocketShutdown.Both);
            socket.Close();
        }
        catch(Exception e)
        {
            Console.WriteLine(e.ToString());
        }
    }
}
{% endhighlight %}

<figure>
  <a href="/assets/img/posts/cshap_network/0.jpg"><img src="/assets/img/posts/cshap_network/0.jpg"></a>
  <a href="/assets/img/posts/cshap_network/1.jpg"><img src="/assets/img/posts/cshap_network/1.jpg"></a>
	<figcaption>C# Multi Thread</figcaption>
</figure>

# Listener
  - make listener to class
  - change blocking methods to non-blocking methods

* ServerCore\Listener.cs
{% highlight C# %}
class Listener
{
    Socket _listenSocket;
    // Action after connecting
    Action<Socket> _onAcceptHandler;

    public void Init(IPEndPoint endPoint, Action<Socket> onAcceptHandler)
    {
        _listenSocket = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        _onAcceptHandler = onAcceptHandler;

        _listenSocket.Bind(endPoint);

        _listenSocket.Listen(10);

        // non-blocking
        // process: register → Accept → register → Accept → ...
        SocketAsyncEventArgs args = new SocketAsyncEventArgs();
        // Case: Accept is not excuted directly, then wait for next accept
        args.Completed += new EventHandler<SocketAsyncEventArgs>(OnAcceptCompleted);
        RegisterAccept(args);
    }

    void RegisterAccept(SocketAsyncEventArgs args)
    {
        // Initialization
        args.AcceptSocket = null;

        // Accept can be excuted randomly
        bool pending = _listenSocket.AcceptAsync(args);
        // Case: Accept is excuted directly
        if (pending == false)
            OnAcceptCompleted(null, args);
    }

    void OnAcceptCompleted(object sender, SocketAsyncEventArgs args)
    {
        if(args.SocketError == SocketError.Success)
        {
            _onAcceptHandler.Invoke(args.AcceptSocket);
        }
        else
            Console.WriteLine(args.SocketError.ToString());

        // This is for next turn client
        RegisterAccept(args);
    }
}
{% endhighlight %}

### Test

* ServerCore\Program.cs
{% highlight C# %}
class Program
{
    static Listener _listener = new Listener();

    static void OnAcceptHandler(Socket clientSocket)
    {
        try
        {
            byte[] recvBuff = new byte[1024];
            int recvBytes = clientSocket.Receive(recvBuff);
            string recvData = Encoding.UTF8.GetString(recvBuff, 0, recvBytes);
            Console.WriteLine($"[From Client] {recvData}");
        
            byte[] sendBuff = Encoding.UTF8.GetBytes("Welcome to MMORPG Server!");
            clientSocket.Send(sendBuff);

            clientSocket.Shutdown(SocketShutdown.Both);
            clientSocket.Close();
        }
        catch(Exception e)
        {
            Console.WriteLine(e);
        }
    }

    static void Main(string[] args)
    {
        string host = Dns.GetHostName();
        IPHostEntry ipHost = Dns.GetHostEntry(host);
        IPAddress ipAddr = ipHost.AddressList[0];
        IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);

        _listener.Init(endPoint, OnAcceptHandler);
        Console.WriteLine("Listening...");

        while (true){ }
    }
}
{% endhighlight %}

* DummyClient\Program.cs
{% highlight C# %}
class Program
{

    static void Main(string[] args)
    {
        string host = Dns.GetHostName();
        IPHostEntry ipHost = Dns.GetHostEntry(host);
        IPAddress ipAddr = ipHost.AddressList[0];
        IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);

        while (true)
        {
            Socket socket = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);

            try
            {
                socket.Connect(endPoint);
                Console.WriteLine($"Connected To {socket.RemoteEndPoint.ToString()}");

                byte[] sendBuff = Encoding.UTF8.GetBytes("Hello World!");
                int sendBytes = socket.Send(sendBuff);

                byte[] recvBuff = new byte[1024];
                int recvBytes = socket.Receive(recvBuff);
                string recvData = Encoding.UTF8.GetString(recvBuff, 0, recvBytes);
                Console.WriteLine($"[From Server] {recvData}");

                socket.Shutdown(SocketShutdown.Both);
                socket.Close();
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }

            Thread.Sleep(100);
        }
    }
}
{% endhighlight %}

<figure class="half">
  <a href="/assets/img/posts/cshap_network/2.jpg"><img src="/assets/img/posts/cshap_network/2.jpg"></a>
  <a href="/assets/img/posts/cshap_network/3.jpg"><img src="/assets/img/posts/cshap_network/3.jpg"></a>
	<figcaption>C# Multi Thread</figcaption>
</figure>

# Session
  - make receive and send to asynchronize
  
## Receive async

* ServerCore\Session.cs
{% highlight C# %}
class Session
{
    Socket _socket;
    int _disconnected = 0;

    public void Start(Socket socket)
    {
        _socket = socket;
        SocketAsyncEventArgs recvArgs = new SocketAsyncEventArgs();
        recvArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnRecvCompleted);

        // SetBuffer is for receiving
        recvArgs.SetBuffer(new byte[1024], 0, 1024);

        RegisterRecv(recvArgs);
    }

    public void Send(byte[] sendBuff)
    {
        _socket.Send(sendBuff);
    }

    public void Disconnect()
    {
        // the connection is already closed
        if (Interlocked.Exchange(ref _disconnected, 1) == 1)
            return;

        _socket.Shutdown(SocketShutdown.Both);
        _socket.Close();
    }

    #region Network Communication

    void RegisterRecv(SocketAsyncEventArgs args)
    {
        bool pending = _socket.ReceiveAsync(args);
        if (pending == false)
            OnRecvCompleted(null, args);
    }

    void OnRecvCompleted(object sender, SocketAsyncEventArgs args)
    {
        if(args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
        {
            try
            {
                string recvData = Encoding.UTF8.GetString(args.Buffer, args.Offset, args.BytesTransferred);
                Console.WriteLine($"[From Client] {recvData}");
                RegisterRecv(args);
            }
            catch(Exception e)
            {
                Console.WriteLine($"OnRecvCompleted Failed {e}");
            }
                
        }
        else 
        { 
            Disconnect();
        }
    }
    #endregion
}
{% endhighlight %}

### Test

* ServerCore\Program.cs
{% highlight C# %}
class Program
{
    static Listener _listener = new Listener();

    static void OnAcceptHandler(Socket clientSocket)
    {
        try
        {
            Session session = new Session();
            session.Start(clientSocket);

            byte[] sendBuff = Encoding.UTF8.GetBytes("Welcome to MMORPG Server!");
            session.Send(sendBuff);

            Thread.Sleep(1000);

            session.Disconnect();
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }

    static void Main(string[] args)
    {
        string host = Dns.GetHostName();
        IPHostEntry ipHost = Dns.GetHostEntry(host);
        IPAddress ipAddr = ipHost.AddressList[0];
        IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);

        _listener.Init(endPoint, OnAcceptHandler);
        Console.WriteLine("Listening...");

        while (true) { }
    }
}
{% endhighlight %}

* DummyClient\Program.cs
{% highlight C# %}
class Program
{
    static void Main(string[] args)
    {
        ...

        while (true)
        {
            ...
            try
            {
                socket.Connect(endPoint);
                Console.WriteLine($"Connected To {socket.RemoteEndPoint.ToString()}");

                for(int i=0; i<5; i++)
                {
                    byte[] sendBuff = Encoding.UTF8.GetBytes("Hello World! {i}");
                    int sendBytes = socket.Send(sendBuff);
                }

                ...
            }
            ...
        }
    }
}
{% endhighlight %}

<figure class="half">
  <a href="/assets/img/posts/cshap_network/4.jpg"><img src="/assets/img/posts/cshap_network/4.jpg"></a>
  <a href="/assets/img/posts/cshap_network/5.jpg"><img src="/assets/img/posts/cshap_network/5.jpg"></a>
	<figcaption>C# Multi Thread</figcaption>
</figure>

## Send async

* ServerCore\Session.cs
{% highlight C# %}
class Session
{
    Socket _socket;
    int _disconnected = 0;

    // for multi thread sending
    object _lock = new object();
    // store sendBuff
    Queue<byte[]> _sendQueue = new Queue<byte[]>();
    // if other client is using sending, then only store sendBuffs on Queue
    bool _pending = false;
    SocketAsyncEventArgs _sendArgs = new SocketAsyncEventArgs();

    public void Start(Socket socket)
    {
        _socket = socket;
        SocketAsyncEventArgs recvArgs = new SocketAsyncEventArgs();
        recvArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnRecvCompleted);
        recvArgs.SetBuffer(new byte[1024], 0, 1024);

        _sendArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnSendCompeleted);

        RegisterRecv(recvArgs);
    }

    public void Send(byte[] sendBuff)
    {
        lock (_lock)
        {
            _sendQueue.Enqueue(sendBuff);
            if (_pending == false)
                RegisterSend();
        }
    }

    public void Disconnect()
    {
        if (Interlocked.Exchange(ref _disconnected, 1) == 1)
            return;

        _socket.Shutdown(SocketShutdown.Both);
        _socket.Close();
    }

    #region Network Communication

    void RegisterSend()
    {
        _pending = true;
        byte[] buff = _sendQueue.Dequeue();
        _sendArgs.SetBuffer(buff, 0, buff.Length);

        bool pending = _socket.SendAsync(_sendArgs);
        if (pending == false)
            OnSendCompeleted(null, _sendArgs);
    }

    void OnSendCompeleted(object sender, SocketAsyncEventArgs args)
    {
        lock (_lock)
        {
            if (args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
            {
                try
                {
                    // if other client store sendBuff on Queue, Register again
                    if (_sendQueue.Count > 0)
                        RegisterSend();
                    else
                        _pending = false;
                }
                catch (Exception e)
                {
                    Console.WriteLine($"OnSendCompeleted Failed {e}");
                }
            }
            else
            {
                Disconnect();
            }
        }
    }

    void RegisterRecv(SocketAsyncEventArgs args)
    {
        bool pending = _socket.ReceiveAsync(args);
        if (pending == false)
            OnRecvCompleted(null, args);
    }

    void OnRecvCompleted(object sender, SocketAsyncEventArgs args)
    {
        if(args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
        {
            try
            {
                string recvData = Encoding.UTF8.GetString(args.Buffer, args.Offset, args.BytesTransferred);
                Console.WriteLine($"[From Client] {recvData}");
                RegisterRecv(args);
            }
            catch(Exception e)
            {
                Console.WriteLine($"OnRecvCompleted Failed {e}");
            }
                
        }
        else
        {
            Disconnect();
        }
    }

    #endregion
}
{% endhighlight %}

### Test

<figure class="half">
  <a href="/assets/img/posts/cshap_network/6.jpg"><img src="/assets/img/posts/cshap_network/6.jpg"></a>
  <a href="/assets/img/posts/cshap_network/7.jpg"><img src="/assets/img/posts/cshap_network/7.jpg"></a>
	<figcaption>C# Multi Thread</figcaption>
</figure>

## Send packet
  - match interface of receive and send
  - make send buffer to package

* ServerCore\Session.cs
{% highlight C# %}
class Session
{
    Socket _socket;
    int _disconnected = 0;

    object _lock = new object();
    Queue<byte[]> _sendQueue = new Queue<byte[]>();
    // for add buffer to BufferList
    List<ArraySegment<byte>> _pendingList = new List<ArraySegment<byte>>();

    SocketAsyncEventArgs _sendArgs = new SocketAsyncEventArgs();
    SocketAsyncEventArgs _recvArgs = new SocketAsyncEventArgs();

    public void Start(Socket socket)
    {
        _socket = socket;

        _recvArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnRecvCompleted);
        _recvArgs.SetBuffer(new byte[1024], 0, 1024);

        _sendArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnSendCompeleted);

        RegisterRecv();
    }

    public void Send(byte[] sendBuff)
    {
        lock (_lock)
        {
            _sendQueue.Enqueue(sendBuff);
            // there is no waiting sending
            if (_pendingList.Count == 0)
                RegisterSend();
        }
    }

    public void Disconnect()
    {
        if (Interlocked.Exchange(ref _disconnected, 1) == 1)
            return;

        _socket.Shutdown(SocketShutdown.Both);
        _socket.Close();
    }

    #region Network Communication

    void RegisterSend()
    {
        // add sendQueue data to BufferList
        while (_sendQueue.Count > 0)
        {
            byte[] buff = _sendQueue.Dequeue();
            _pendingList.Add(new ArraySegment<byte>(buff, 0, buff.Length));
        }

        _sendArgs.BufferList = _pendingList;

        bool pending = _socket.SendAsync(_sendArgs);
        if (pending == false)
            OnSendCompeleted(null, _sendArgs);
    }

    void OnSendCompeleted(object sender, SocketAsyncEventArgs args)
    {
        lock (_lock)
        {
            if (args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
            {
                try
                {
                    // Initialize
                    _sendArgs.BufferList = null;
                    _pendingList.Clear();

                    Console.WriteLine($"Transferred bytes: {_sendArgs.BytesTransferred}");
                        
                    if (_sendQueue.Count > 0)
                        RegisterSend();
                }
                catch (Exception e)
                {
                    Console.WriteLine($"OnSendCompeleted Failed {e}");
                }
            }
            else
            {
                Disconnect();
            }            }
    }

    void RegisterRecv()
    {
        bool pending = _socket.ReceiveAsync(_recvArgs);
        if (pending == false)
            OnRecvCompleted(null, _recvArgs);
    }

    void OnRecvCompleted(object sender, SocketAsyncEventArgs args)
    {
        if(args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
        {
            try
            {
                string recvData = Encoding.UTF8.GetString(args.Buffer, args.Offset, args.BytesTransferred);
                Console.WriteLine($"[From Client] {recvData}");
                RegisterRecv();
            }
            catch(Exception e)
            {
                Console.WriteLine($"OnRecvCompleted Failed {e}");
            }
                
        }
        else
        {
            Disconnect();
        }
    }
    #endregion
}
{% endhighlight %}

### Test

<figure class="half">
  <a href="/assets/img/posts/cshap_network/8.jpg"><img src="/assets/img/posts/cshap_network/8.jpg"></a>
  <a href="/assets/img/posts/cshap_network/9.jpg"><img src="/assets/img/posts/cshap_network/9.jpg"></a>
	<figcaption>C# Multi Thread</figcaption>
</figure>

## seperate Session 
  - seperate engine and contents
  - add EventHandler

* ServerCore\Session.cs
  - Core Engine

{% highlight C# %}
abstract class Session
{
    Socket _socket;
    int _disconnected = 0;

    object _lock = new object();
    Queue<byte[]> _sendQueue = new Queue<byte[]>();
    List<ArraySegment<byte>> _pendingList = new List<ArraySegment<byte>>();

    SocketAsyncEventArgs _sendArgs = new SocketAsyncEventArgs();
    SocketAsyncEventArgs _recvArgs = new SocketAsyncEventArgs();

    // contents
    public abstract void OnConnected(EndPoint endPoint); // This is on Listener
    public abstract void OnRecv(ArraySegment<byte> buffer);
    public abstract void OnSend(int numOfBytes);
    public abstract void OnDisconnected(EndPoint endPoint);


    public void Start(Socket socket)
    {
        _socket = socket;

        _recvArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnRecvCompleted);
        _recvArgs.SetBuffer(new byte[1024], 0, 1024);

        _sendArgs.Completed += new EventHandler<SocketAsyncEventArgs>(OnSendCompeleted);

        RegisterRecv();
    }

    public void Send(byte[] sendBuff)
    {
        lock (_lock)
        {
            _sendQueue.Enqueue(sendBuff);
            if (_pendingList.Count == 0)
                RegisterSend();
        }
    }

    public void Disconnect()
    {
        if (Interlocked.Exchange(ref _disconnected, 1) == 1)
            return;

        OnDisconnected(_socket.RemoteEndPoint);
        _socket.Shutdown(SocketShutdown.Both);
        _socket.Close();
    }

    #region Network Communication

    void RegisterSend()
    {
        while (_sendQueue.Count > 0)
        {
            byte[] buff = _sendQueue.Dequeue();
            _pendingList.Add(new ArraySegment<byte>(buff, 0, buff.Length));
        }

        _sendArgs.BufferList = _pendingList;

        bool pending = _socket.SendAsync(_sendArgs);
        if (pending == false)
            OnSendCompeleted(null, _sendArgs);
    }

    void OnSendCompeleted(object sender, SocketAsyncEventArgs args)
    {
        lock (_lock)
        {
            if (args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
            {
                try
                {
                    _sendArgs.BufferList = null;
                    _pendingList.Clear();

                    OnSend(_sendArgs.BytesTransferred);
                        
                    if (_sendQueue.Count > 0)
                        RegisterSend();
                }
                catch (Exception e)
                {
                    Console.WriteLine($"OnSendCompeleted Failed {e}");
                }
            }
            else
            {
                Disconnect();
            }
        }
    }

    void RegisterRecv()
    {
        bool pending = _socket.ReceiveAsync(_recvArgs);
        if (pending == false)
            OnRecvCompleted(null, _recvArgs);
    }

    void OnRecvCompleted(object sender, SocketAsyncEventArgs args)
    {
        if(args.BytesTransferred > 0 && args.SocketError == SocketError.Success)
        {
            try
            {
                OnRecv(new ArraySegment<byte>(args.Buffer, args.Offset, args.BytesTransferred));
                RegisterRecv();
            }
            catch(Exception e)
            {
                Console.WriteLine($"OnRecvCompleted Failed {e}");
            }
                
        }
        else
        {
            Disconnect();
        }
    }
    #endregion
}
{% endhighlight %}

* ServerCore\Listener.cs
{% highlight C# %}
class Listener
{
    Socket _listenSocket;
    // Define Session by _sessionFactory
    Func<Session> _sessionFactory;

    public void Init(IPEndPoint endPoint, Func<Session> sessionFactory)
    {
        _listenSocket = new Socket(endPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        _sessionFactory = sessionFactory;

        _listenSocket.Bind(endPoint);

        _listenSocket.Listen(10);

        SocketAsyncEventArgs args = new SocketAsyncEventArgs();
        args.Completed += new EventHandler<SocketAsyncEventArgs>(OnAcceptCompleted);
        RegisterAccept(args);
    }

    void RegisterAccept(SocketAsyncEventArgs args)
    {
        args.AcceptSocket = null;

        bool pending = _listenSocket.AcceptAsync(args);
        if (pending == false)
            OnAcceptCompleted(null, args);
    }

    void OnAcceptCompleted(object sender, SocketAsyncEventArgs args)
    {
        if(args.SocketError == SocketError.Success)
        {
            // For all type of session
            Session session = _sessionFactory.Invoke();
            session.Start(args.AcceptSocket);
            session.OnConnected(args.AcceptSocket.RemoteEndPoint);
        }
        else
            Console.WriteLine(args.SocketError.ToString());

        RegisterAccept(args);
    }
}
{% endhighlight %}

* ServerCore\Program.cs
{% highlight C# %}

// Event Handler
class GameSession : Session
{
    public override void OnConnected(EndPoint endPoint)
    {
        Console.WriteLine($"OnConnected: {endPoint}");

        byte[] sendBuff = Encoding.UTF8.GetBytes("Welcome to MMORPG Server!");
        Send(sendBuff);

        Thread.Sleep(1000);

        Disconnect();
    }

    public override void OnDisconnected(EndPoint endPoint)
    {
        Console.WriteLine($"OnDisconnected: {endPoint}");
    }

    public override void OnRecv(ArraySegment<byte> buffer)
    {
        string recvData = Encoding.UTF8.GetString(buffer.Array, buffer.Offset, buffer.Count);
        Console.WriteLine($"[From Client] {recvData}");
    }

    public override void OnSend(int numOfBytes)
    {
        Console.WriteLine($"Transferred bytes: {numOfBytes}");
    }
}

class Program
{
    static Listener _listener = new Listener();

    static void Main(string[] args)
    {
        string host = Dns.GetHostName();
        IPHostEntry ipHost = Dns.GetHostEntry(host);
        IPAddress ipAddr = ipHost.AddressList[0];
        IPEndPoint endPoint = new IPEndPoint(ipAddr, 7777);

        // Create GameSession by rambda func
        _listener.Init(endPoint, ()=> { return new GameSession(); });
        Console.WriteLine("Listening...");

        while (true) { }
    }
}
{% endhighlight %}

### Test

<figure class="half">
  <a href="/assets/img/posts/cshap_network/10.jpg"><img src="/assets/img/posts/cshap_network/10.jpg"></a>
  <a href="/assets/img/posts/cshap_network/11.jpg"><img src="/assets/img/posts/cshap_network/11.jpg"></a>
	<figcaption>C# Multi Thread</figcaption>
</figure>

[Download](https://github.com/leehuhlee/CShap){: .btn}
